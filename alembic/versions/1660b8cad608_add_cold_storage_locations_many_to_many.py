"""add_cold_storage_locations_many_to_many

Revision ID: 1660b8cad608
Revises: f263f88663c0
Create Date: 2026-01-08 06:37:39.715671

"""
from typing import Sequence, Union

import sqlalchemy as sa

from alembic import op

# revision identifiers, used by Alembic.
revision: str = "1660b8cad608"
down_revision: Union[str, None] = "f263f88663c0"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table("cold_storage_locations",
    sa.Column("id", sa.Integer(), nullable=False),
    sa.Column("name", sa.String(), nullable=False),
    sa.Column("path", sa.String(), nullable=False),
    sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("(CURRENT_TIMESTAMP)"), nullable=True),
    sa.Column("updated_at", sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint("id"),
    sa.UniqueConstraint("path")
    )
    op.create_index(op.f("ix_cold_storage_locations_id"), "cold_storage_locations", ["id"], unique=False)
    op.create_index(op.f("ix_cold_storage_locations_name"), "cold_storage_locations", ["name"], unique=True)
    op.create_table("path_storage_location_association",
    sa.Column("path_id", sa.Integer(), nullable=False),
    sa.Column("storage_location_id", sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(["path_id"], ["monitored_paths.id"], ),
    sa.ForeignKeyConstraint(["storage_location_id"], ["cold_storage_locations.id"], ),
    sa.PrimaryKeyConstraint("path_id", "storage_location_id")
    )

    # Data migration: Migrate existing cold_storage_path values to new structure
    from sqlalchemy import orm  # noqa: PLC0415
    bind = op.get_bind()
    session = orm.Session(bind=bind)

    # Get all monitored paths with their cold_storage_path
    paths_result = session.execute(
        sa.text("SELECT id, name, cold_storage_path FROM monitored_paths WHERE cold_storage_path IS NOT NULL")
    )

    # Track unique storage paths and their IDs
    storage_path_to_id = {}

    for path_row in paths_result:
        path_id = path_row[0]
        path_name = path_row[1]
        storage_path = path_row[2]

        # Check if we already created a storage location for this path
        if storage_path not in storage_path_to_id:
            # Check if location already exists
            existing_loc = session.execute(
                sa.text("SELECT id FROM cold_storage_locations WHERE path = :path"),
                {"path": storage_path}
            ).fetchone()

            if existing_loc:
                storage_location_id = existing_loc[0]
            else:
                # Create a new storage location
                # Generate a unique name based on the path
                location_name = f"Storage for {path_name}"

                # Ensure name is unique
                name_counter = 1
                original_name = location_name
                while True:
                    name_check = session.execute(
                        sa.text("SELECT id FROM cold_storage_locations WHERE name = :name"),
                        {"name": location_name}
                    ).fetchone()
                    if not name_check:
                        break
                    name_counter += 1
                    location_name = f"{original_name} ({name_counter})"

                # Insert new storage location
                _ = session.execute(
                    sa.text(
                        "INSERT INTO cold_storage_locations (name, path) VALUES (:name, :path)"
                    ),
                    {"name": location_name, "path": storage_path}
                )
                session.commit()

                # Get the ID of the newly created location
                storage_location_id = session.execute(
                    sa.text("SELECT id FROM cold_storage_locations WHERE path = :path"),
                    {"path": storage_path}
                ).fetchone()[0]

            storage_path_to_id[storage_path] = storage_location_id
        else:
            storage_location_id = storage_path_to_id[storage_path]

        # Create association between path and storage location
        session.execute(
            sa.text(
                "INSERT OR IGNORE INTO path_storage_location_association (path_id, storage_location_id) VALUES (:path_id, :storage_location_id)"
            ),
            {"path_id": path_id, "storage_location_id": storage_location_id}
        )
        session.commit()

    session.close()

    # Note: cold_storage_path column will be dropped in a separate migration (ee17616b5a90)
    # to ensure clean upgrade path for existing deployments

    op.drop_index(op.f("idx_inventory_checksum"), table_name="file_inventory")
    op.drop_index(op.f("idx_file_tags_file_id"), table_name="file_tags")
    op.drop_index(op.f("idx_file_tags_tag_id"), table_name="file_tags")
    op.drop_column("monitored_paths", "cleanup_enabled")
    op.drop_index(op.f("idx_tag_rules_enabled"), table_name="tag_rules")
    op.drop_index(op.f("idx_tag_rules_priority"), table_name="tag_rules")
    op.drop_index(op.f("idx_tag_rules_tag_id"), table_name="tag_rules")
    op.drop_index(op.f("idx_tags_name"), table_name="tags")
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_index(op.f("idx_tags_name"), "tags", ["name"], unique=False)
    op.create_index(op.f("idx_tag_rules_tag_id"), "tag_rules", ["tag_id"], unique=False)
    op.create_index(op.f("idx_tag_rules_priority"), "tag_rules", ["priority"], unique=False)
    op.create_index(op.f("idx_tag_rules_enabled"), "tag_rules", ["enabled"], unique=False)
    op.add_column("monitored_paths", sa.Column("cleanup_enabled", sa.BOOLEAN(), server_default=sa.text("'0'"), nullable=False))
    op.create_index(op.f("idx_file_tags_tag_id"), "file_tags", ["tag_id"], unique=False)
    op.create_index(op.f("idx_file_tags_file_id"), "file_tags", ["file_id"], unique=False)
    op.create_index(op.f("idx_inventory_checksum"), "file_inventory", ["checksum"], unique=False)

    # Note: cold_storage_path column restoration is handled in migration ee17616b5a90

    op.drop_table("path_storage_location_association")
    op.drop_index(op.f("ix_cold_storage_locations_name"), table_name="cold_storage_locations")
    op.drop_index(op.f("ix_cold_storage_locations_id"), table_name="cold_storage_locations")
    op.drop_table("cold_storage_locations")
    # ### end Alembic commands ###
