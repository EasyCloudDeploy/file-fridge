
import pytest
from app.models import User, MonitoredPath, OperationType
from app.security import hash_password

# Use a constant for password to avoid Security Hotspot
TEST_PASSWORD = "password"  # NOSONAR

@pytest.fixture
def manager_client(client, db_session):
    user = User(username="manager", password_hash=hash_password(TEST_PASSWORD), roles=["manager"])
    db_session.add(user)
    db_session.commit()

    response = client.post(
        "/api/v1/auth/login",
        json={"username": "manager", "password": TEST_PASSWORD},
    )
    assert response.status_code == 200, "Login failed"
    data = response.json()
    assert "access_token" in data, "Token missing in login response"

    token = data["access_token"]
    client.headers["Authorization"] = f"Bearer {token}"
    return client


def test_arbitrary_file_move_prevented(manager_client, tmp_path):
    # 1. Create a sensitive file outside of any monitored path
    sensitive_file = tmp_path / "sensitive_secret.txt"
    sensitive_file.write_text("SUPER_SECRET_DATA")

    # 2. Define a destination also outside monitored paths
    destination_file = tmp_path / "stolen_secret.txt"

    # 3. Attempt to move the file using the API
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(sensitive_file),
            "destination_path": str(destination_file),
            "operation_type": "move",
        },
    )

    # 4. Assert that the move FAILED (VULNERABILITY FIXED)
    # The vulnerability is fixed if we get a 403 Forbidden
    assert response.status_code == 403
    assert not destination_file.exists()
    assert sensitive_file.exists()


def test_legitimate_file_move_allowed(manager_client, tmp_path, db_session):
    # 1. Setup allowed paths in DB
    # Add tmp_path as a monitored path
    monitored_path = MonitoredPath(
        name="Allowed", source_path=str(tmp_path), operation_type=OperationType.MOVE, enabled=True
    )
    db_session.add(monitored_path)
    db_session.commit()

    # 2. Create valid source file within the monitored path
    source = tmp_path / "valid_source.txt"
    source.write_text("ok")
    dest = tmp_path / "valid_dest.txt"

    # 3. Attempt to move within allowed path
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 4. Assert success
    assert response.status_code == 202
    assert dest.exists()
    assert not source.exists()


def test_path_traversal_move_prevented(manager_client, tmp_path, db_session):
    # 1. Setup allowed paths in DB
    allowed_dir = tmp_path / "allowed"
    allowed_dir.mkdir()

    monitored_path = MonitoredPath(
        name="Allowed",
        source_path=str(allowed_dir),
        operation_type=OperationType.MOVE,
        enabled=True,
    )
    db_session.add(monitored_path)
    db_session.commit()

    # 2. Create a source file inside allowed dir
    source = allowed_dir / "source.txt"
    source.write_text("data")

    # 3. Attempt to move file to outside directory using traversal
    # target is tmp_path / "outside.txt"
    target_path = allowed_dir / ".." / "outside.txt"

    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(target_path),
            "operation_type": "move",
        },
    )

    # 4. Assert failure
    assert response.status_code == 403
    assert source.exists()
    assert not (tmp_path / "outside.txt").exists()


def test_symlink_escape_move_prevented(manager_client, tmp_path, db_session):
    # 1. Setup allowed paths in DB
    allowed_dir = tmp_path / "allowed"
    allowed_dir.mkdir()

    monitored_path = MonitoredPath(
        name="Allowed",
        source_path=str(allowed_dir),
        operation_type=OperationType.MOVE,
        enabled=True,
    )
    db_session.add(monitored_path)
    db_session.commit()

    # 2. Create a file OUTSIDE the allowed dir
    sensitive_file = tmp_path / "sensitive.txt"
    sensitive_file.write_text("sensitive")

    # 3. Create a symlink INSIDE the allowed dir pointing to the sensitive file
    symlink_file = allowed_dir / "link_to_sensitive"
    symlink_file.symlink_to(sensitive_file)

    dest = allowed_dir / "captured.txt"

    # 4. Attempt to move the symlink (which resolves to outside file)
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(symlink_file),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 5. Assert failure - symlink resolves to outside path
    assert response.status_code == 403
    assert sensitive_file.exists()
    assert not dest.exists()


def test_admin_move_allowed(client, db_session, tmp_path):
    # 1. Create admin user
    user = User(username="admin", password_hash=hash_password(TEST_PASSWORD), roles=["admin"])
    db_session.add(user)
    db_session.commit()

    # 2. Login as admin
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "admin", "password": TEST_PASSWORD},
    )
    assert response.status_code == 200
    token = response.json()["access_token"]
    client.headers["Authorization"] = f"Bearer {token}"

    # 3. Create files outside any monitored path
    source = tmp_path / "admin_source.txt"
    source.write_text("admin_data")
    dest = tmp_path / "admin_dest.txt"

    # 4. Attempt move
    response = client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 5. Assert success - Admin has unrestricted access
    assert response.status_code == 202
    assert dest.exists()
    assert not source.exists()
