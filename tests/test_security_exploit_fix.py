
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool
from pathlib import Path

from app.database import Base, get_db
from app.main import app
from app.config import settings
from app.models import User, MonitoredPath, OperationType
from app.security import hash_password

@pytest.fixture
def setup_app():
    # Store original values
    original_db_path = settings.database_path
    original_secret_key = settings.secret_key
    original_encryption_key = settings.encryption_key_file
    original_fingerprint_verification = settings.require_fingerprint_verification

    # Override settings for testing
    settings.database_path = ":memory:"
    settings.secret_key = "test-secret-key"
    settings.encryption_key_file = "./test_encryption.key"
    settings.require_fingerprint_verification = False

    # Use an in-memory SQLite database for tests
    engine = create_engine(
        "sqlite:///:memory:",
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

    def override_get_db():
        db = TestingSessionLocal()
        try:
            yield db
        finally:
            db.close()

    app.dependency_overrides[get_db] = override_get_db

    yield engine, TestingSessionLocal

    # Restore settings
    settings.database_path = original_db_path
    settings.secret_key = original_secret_key
    settings.encryption_key_file = original_encryption_key
    settings.require_fingerprint_verification = original_fingerprint_verification
    app.dependency_overrides.pop(get_db, None)

@pytest.fixture
def client(setup_app):
    engine, _ = setup_app
    Base.metadata.create_all(bind=engine)
    with TestClient(app) as test_client:
        yield test_client
    Base.metadata.drop_all(bind=engine)

@pytest.fixture
def manager_client(client, setup_app):
    _, SessionLocal = setup_app
    db = SessionLocal()
    user = User(username="manager", password_hash=hash_password("password"), roles=["manager"])
    db.add(user)
    db.commit()
    db.close()

    response = client.post(
        "/api/v1/auth/login",
        json={"username": "manager", "password": "password"},
    )
    assert response.status_code == 200, "Login failed"
    data = response.json()
    assert "access_token" in data, "Token missing in login response"

    token = data["access_token"]
    client.headers["Authorization"] = f"Bearer {token}"
    return client

def test_arbitrary_file_move_prevented(manager_client, tmp_path):
    # 1. Create a sensitive file outside of any monitored path
    sensitive_file = tmp_path / "sensitive_secret.txt"
    sensitive_file.write_text("SUPER_SECRET_DATA")

    # 2. Define a destination also outside monitored paths
    destination_file = tmp_path / "stolen_secret.txt"

    # 3. Attempt to move the file using the API
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(sensitive_file),
            "destination_path": str(destination_file),
            "operation_type": "move",
        },
    )

    # 4. Assert that the move FAILED (VULNERABILITY FIXED)
    # The vulnerability is fixed if we get a 403 Forbidden
    assert response.status_code == 403
    assert not destination_file.exists()
    assert sensitive_file.exists()

def test_legitimate_file_move_allowed(manager_client, tmp_path, setup_app):
    # 1. Setup allowed paths in DB
    _, SessionLocal = setup_app
    db = SessionLocal()
    # Add tmp_path as a monitored path
    monitored_path = MonitoredPath(
        name="Allowed",
        source_path=str(tmp_path),
        operation_type=OperationType.MOVE,
        enabled=True
    )
    db.add(monitored_path)
    db.commit()
    db.close()

    # 2. Create valid source file within the monitored path
    source = tmp_path / "valid_source.txt"
    source.write_text("ok")
    dest = tmp_path / "valid_dest.txt"

    # 3. Attempt to move within allowed path
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 4. Assert success
    assert response.status_code == 202
    assert dest.exists()
    assert not source.exists()

def test_path_traversal_move_prevented(manager_client, tmp_path, setup_app):
    # 1. Setup allowed paths in DB
    _, SessionLocal = setup_app
    db = SessionLocal()

    allowed_dir = tmp_path / "allowed"
    allowed_dir.mkdir()

    monitored_path = MonitoredPath(
        name="Allowed",
        source_path=str(allowed_dir),
        operation_type=OperationType.MOVE,
        enabled=True
    )
    db.add(monitored_path)
    db.commit()
    db.close()

    # 2. Create a source file inside allowed dir
    source = allowed_dir / "source.txt"
    source.write_text("data")

    # 3. Attempt to move file to outside directory using traversal
    # target is tmp_path / "outside.txt"
    target_path = allowed_dir / ".." / "outside.txt"

    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(target_path),
            "operation_type": "move",
        },
    )

    # 4. Assert failure
    assert response.status_code == 403
    assert source.exists()
    assert not (tmp_path / "outside.txt").exists()

def test_symlink_escape_move_prevented(manager_client, tmp_path, setup_app):
    # 1. Setup allowed paths in DB
    _, SessionLocal = setup_app
    db = SessionLocal()

    allowed_dir = tmp_path / "allowed"
    allowed_dir.mkdir()

    monitored_path = MonitoredPath(
        name="Allowed",
        source_path=str(allowed_dir),
        operation_type=OperationType.MOVE,
        enabled=True
    )
    db.add(monitored_path)
    db.commit()
    db.close()

    # 2. Create a file OUTSIDE the allowed dir
    sensitive_file = tmp_path / "sensitive.txt"
    sensitive_file.write_text("sensitive")

    # 3. Create a symlink INSIDE the allowed dir pointing to the sensitive file
    symlink_file = allowed_dir / "link_to_sensitive"
    symlink_file.symlink_to(sensitive_file)

    dest = allowed_dir / "captured.txt"

    # 4. Attempt to move the symlink (which resolves to outside file)
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(symlink_file),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 5. Assert failure - symlink resolves to outside path
    assert response.status_code == 403
    assert sensitive_file.exists()
    assert not dest.exists()

def test_admin_move_allowed(client, setup_app, tmp_path):
    # 1. Create admin user
    _, SessionLocal = setup_app
    db = SessionLocal()
    user = User(username="admin", password_hash=hash_password("password"), roles=["admin"])
    db.add(user)
    db.commit()
    db.close()

    # 2. Login as admin
    response = client.post(
        "/api/v1/auth/login",
        json={"username": "admin", "password": "password"},
    )
    assert response.status_code == 200
    token = response.json()["access_token"]
    client.headers["Authorization"] = f"Bearer {token}"

    # 3. Create files outside any monitored path
    source = tmp_path / "admin_source.txt"
    source.write_text("admin_data")
    dest = tmp_path / "admin_dest.txt"

    # 4. Attempt move
    response = client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 5. Assert success - Admin has unrestricted access
    assert response.status_code == 202
    assert dest.exists()
    assert not source.exists()
