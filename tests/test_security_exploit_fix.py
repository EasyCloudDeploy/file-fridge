
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool
from pathlib import Path

from app.database import Base, get_db
from app.main import app
from app.config import settings
from app.models import User, MonitoredPath, OperationType
from app.security import hash_password

# Override settings for testing
settings.database_path = ":memory:"
settings.secret_key = "test-secret-key"
settings.encryption_key_file = "./test_encryption.key"
settings.require_fingerprint_verification = False

# Use an in-memory SQLite database for tests
engine = create_engine(
    "sqlite:///:memory:",
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()

app.dependency_overrides[get_db] = override_get_db

@pytest.fixture(scope="function")
def client():
    Base.metadata.create_all(bind=engine)
    with TestClient(app) as test_client:
        yield test_client
    Base.metadata.drop_all(bind=engine)

@pytest.fixture
def manager_client(client):
    db = TestingSessionLocal()
    user = User(username="manager", password_hash=hash_password("password"), roles=["manager"])
    db.add(user)
    db.commit()
    db.close()

    response = client.post(
        "/api/v1/auth/login",
        json={"username": "manager", "password": "password"},
    )
    token = response.json()["access_token"]
    client.headers["Authorization"] = f"Bearer {token}"
    return client

def test_arbitrary_file_move_prevented(manager_client, tmp_path):
    # 1. Create a sensitive file outside of any monitored path
    sensitive_file = tmp_path / "sensitive_secret.txt"
    sensitive_file.write_text("SUPER_SECRET_DATA")

    # 2. Define a destination also outside monitored paths
    destination_file = tmp_path / "stolen_secret.txt"

    # 3. Attempt to move the file using the API
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(sensitive_file),
            "destination_path": str(destination_file),
            "operation_type": "move",
        },
    )

    # 4. Assert that the move FAILED (VULNERABILITY FIXED)
    # The vulnerability is fixed if we get a 403 Forbidden
    assert response.status_code == 403
    assert not destination_file.exists()
    assert sensitive_file.exists()

def test_legitimate_file_move_allowed(manager_client, tmp_path):
    # 1. Setup allowed paths in DB
    db = TestingSessionLocal()
    # Add tmp_path as a monitored path
    monitored_path = MonitoredPath(name="Allowed", source_path=str(tmp_path), operation_type=OperationType.MOVE, enabled=True)
    db.add(monitored_path)
    db.commit()
    db.close()

    # 2. Create valid source file within the monitored path
    source = tmp_path / "valid_source.txt"
    source.write_text("ok")
    dest = tmp_path / "valid_dest.txt"

    # 3. Attempt to move within allowed path
    response = manager_client.post(
        "/api/v1/files/move",
        json={
            "source_path": str(source),
            "destination_path": str(dest),
            "operation_type": "move",
        },
    )

    # 4. Assert success
    assert response.status_code == 202
    assert dest.exists()
    assert not source.exists()
